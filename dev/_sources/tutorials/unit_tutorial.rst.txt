.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_unit_tutorial.py>`     to download the full example code
    .. rst-class:: sphx-glr-example-title

    .. _sphx_glr_tutorials_unit_tutorial.py:


==================
Working With Units
==================

Early in our scientific careers we all learn about the importance of paying
attention to units in our calculations. Unit conversions can still get the best
of us and have caused more than one major technical disaster, including the
crash and complete loss of the $327 million Mars Climate Orbiter.

In MetPy, we use the :mod:`pint` library and a custom unit registry to help prevent
unit mistakes in calculations. That means that every quantity you pass to MetPy
should have units attached, just like if you were doing the calculation on
paper! This simplifies the MetPy API by eliminating the need to specify units
various functions. Instead, only the final results need to be converted to desired units. For
more information on unit support, see the documentation for
`Pint <http://pint.readthedocs.io>`_. Particular attention should be paid to the support
for `temperature units <https://pint.readthedocs.io/en/latest/nonmult.html>`_.

In this tutorial we'll show some examples of working with units and get you on your way to
utilizing the computation functions in MetPy.

Getting Started
---------------
To use units, the first step is to import the default MetPy units registry from the
:mod:`~metpy.units` module:


.. code-block:: default

    import numpy as np

    import metpy.calc as mpcalc
    from metpy.units import units








The unit registry encapsulates all of the available units, as well as any pertinent settings.
The registry also understands unit prefixes and suffixes; this allows the registry to
understand ``'kilometer'`` and ``'meters'`` in addition to the base ``'meter'`` unit.

In general, using units is only a small step on top of using the :class:`numpy.ndarray`
object.

Adding Units to Data
--------------------
The easiest way to attach units to an array (or integer, float, etc.) is to multiply by the
units:


.. code-block:: default

    distance = np.arange(1, 5) * units.meters








It is also possible to directly construct a :class:`pint.Quantity`, with a full units string:


.. code-block:: default

    time = units.Quantity(np.arange(2, 10, 2), 'sec')








Compound units can be constructed by the direct mathematical operations necessary:


.. code-block:: default

    9.81 * units.meter / (units.second * units.second)






.. raw:: html

    9.81 meter/second<sup>2</sup>
    <br />
    <br />

This verbose syntax can be reduced by using the unit registry's support for parsing units:


.. code-block:: default

    9.81 * units('m/s^2')






.. raw:: html

    9.81 meter/second<sup>2</sup>
    <br />
    <br />

Operations With Units
---------------------
With units attached, it is possible to perform mathematical operations, resulting in the
proper units:


.. code-block:: default

    print(distance / time)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [0.5 0.5 0.5 0.5] meter / second




For multiplication and division, units can combine and cancel. For addition and subtraction,
instead the operands must have compatible units. For instance, this works:


.. code-block:: default

    print(distance + distance)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [2 4 6 8] meter




But for instance, `distance + time` would not work; instead it gives an error:

`DimensionalityError: Cannot convert from 'meter' ([length]) to 'second' ([time])`

Even if the units are not identical, as long as they are dimensionally equivalent, the
operation can be performed:


.. code-block:: default

    print(3 * units.inch + 5 * units.cm)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    4.968503937007874 inch




Converting Units
----------------

Converting a :class:`~pint.Quantity` between units can be accomplished by using the
:meth:`~pint.Quantity.to` method call, which constructs a new :class:`~pint.Quantity` in the
desired units:


.. code-block:: default


    print((1 * units.inch).to(units.mm))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    25.4 millimeter




There is also the :meth:`~pint.Quantity.ito` method which performs the same operation
in-place:


.. code-block:: default

    a = np.arange(5.) * units.meter
    a.ito('feet')
    print(a)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [0.0 3.2808398950131235 6.561679790026247 9.84251968503937 13.123359580052494] foot




To simplify units, there is also the :meth:`~pint.Quantity.to_base_units` method,
which converts a quantity to SI units, performing any needed cancellation:


.. code-block:: default

    Lf = 3.34e6 * units('J/kg')
    print(Lf, Lf.to_base_units(), sep='\n')





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    3340000.0 joule / kilogram
    3340000.0 meter ** 2 / second ** 2




:meth:`~pint.Quantity.to_base_units` can also be done in-place via the
:meth:`~pint.Quantity.ito_base_units` method.

By default Pint does not do any more than simple unit simplification, so when you perform
operations you could get some seemingly odd results:


.. code-block:: default

    length = 10.4 * units.inch
    width = 5 * units.cm
    area = length * width
    print(area)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    52.0 centimeter * inch




This is another place where :meth:`~pint.Quantity.to` comes in handy:


.. code-block:: default

    print(area.to('m^2'))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    0.013208 meter ** 2




Temperature
-----------
Temperature units are actually relatively tricky (more like absolutely tricky as
you'll see). Temperature is a non-multiplicative unit - they are in a system
with a reference point. That means that not only is there a scaling factor, but
also an offset. This makes the math and unit book-keeping a little more complex.
Imagine adding 10 degrees Celsius to 100 degrees Celsius. Is the answer 110
degrees Celsius or 383.15 degrees Celsius (283.15 K + 373.15 K)? That's why
there are delta degrees units in the unit registry for offset units. For more
examples and explanation you can watch MetPy Monday #13:
https://www.youtube.com/watch?v=iveJCqxe3Z4.

Let's take a look at how this works and fails:

We would expect this to fail because we cannot add two offset units (and it does
fail as an "Ambiguous operation with offset unit").

`10 * units.degC + 5 * units.degC`

On the other hand, we can subtract two offset quantities and get a delta. A delta unit is
pint's way of representing a relative change in two offset units, indicating that this is
not an absolute value of 5 degrees Celsius, but a relative change of 5 degrees Celsius.


.. code-block:: default

    print(10 * units.degC - 5 * units.degC)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    5 delta_degree_Celsius




We can add a delta to an offset unit as well since it is a relative change.


.. code-block:: default

    print(25 * units.degC + 5 * units.delta_degF)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    27.77777777777778 degree_Celsius




Absolute temperature scales like Kelvin and Rankine do not have an offset
and therefore can be used in addition/subtraction without the need for a
delta version of the unit.


.. code-block:: default

    print(273 * units.kelvin + 10 * units.kelvin)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    283 kelvin





.. code-block:: default

    print(273 * units.kelvin - 10 * units.kelvin)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    263 kelvin




MetPy Calculations
------------------
All MetPy calculations are unit-aware and rely on this information to ensure
that the calculations operate correctly. For example, we can use units to take
an observation in whatever units are most convenient and let MetPy handle everything
under the hood. Below we calculate dewpoint from the temperature and relative humidity:


.. code-block:: default

    temperature = 73.2 * units.degF
    rh = 64 * units.percent
    dewpoint = mpcalc.dewpoint_from_relative_humidity(temperature, rh)

    print(dewpoint)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    15.726236381245268 degree_Celsius




or back to Fahrenheit:


.. code-block:: default

    print(dewpoint.to('degF'))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    60.3072254862414 degree_Fahrenheit




Common Mistakes
---------------
There are a few common mistakes the new users often make. Be sure to check
these when you're having issues.

* Pressure units are `mbar` or `hPa` for common atmospheric measurements. The
  unit `mb` is actually millibarns--a unit used in particle physics.
* When using masked arrays, units must be multiplied on the left side. This
  will be addressed in the future, but is a current limitation in the
  ecosystem. The expected error will be
  `AttributeError: 'MaskedArray' object has no attribute 'units'` or calculation
  functions complaining about expecting a units and getting "dimensionless".


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.014 seconds)


.. _sphx_glr_download_tutorials_unit_tutorial.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: unit_tutorial.py <unit_tutorial.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: unit_tutorial.ipynb <unit_tutorial.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
